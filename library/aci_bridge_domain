#!/usr/bin/python

DOCUMENTATION = '''
---

module: aci_bridge_domain
short_description: Direct access to the APIC API
description:
    - Offers direct access to the APIC API
author: Cisco
requirements:
    - ACI Fabric 1.0(3f)+
notes:
    - Tenant should already exist
options:
   action:
        description:
            - post or get
        required: true
        default: null
        choices: ['post', 'get']
        aliases: []
   tenant_name:
        description:
            - Tenant Name
        required: true
        default: null
        choices: []
        aliases: []
   bd_name:
        description:
            - Bridge Domain
        required: true
        default: null
        choices: []
        aliases: []
   vrf_name:
        description:
            - VRF name to associate to the Bridge Domain
        required: true
        default: null
        choices: []
        aliases: []
   arp_flooding:
        description:
            - Enable or Disable ARP_Flooding
        required: true
        default: null
        choices: []
        aliases: []
    l3_out:
        description:
            - Name of the External routed network (L3Out) to associate
        required: false
        default: null
        choices: []
        aliases: []
    gateway_ip:
        description:
            - Gateway IP for subnet
        required: true
        default: null
        choices: []
        aliases: [] 
    subnet_mask:
        description:
            - Value of the subnet mask 
        required: true 
        default: null 
        choices: []
        aliases: [] 
    scope:
        description:
            - Subent Scope - can be private or public and shared  
        required: false 
        default: 'private'
        choices: []
        aliases: []
    dhcp_name:
        description:
            - Name for the DHCP relay label to be added  
        required: false 
        default: null 
        choices: []
        aliases: []
    dhcp_scope:
        description:
            - DHCP Relay label scope can be either tenant or infra 
        required: false 
        default: 'infra' 
        choices: ['tenant','infra']
        aliases: []
    host:
        description:
            - IP Address or hostname of APIC resolvable by Ansible control host
        required: true
        default: null
        choices: []
        aliases: []
    username:
        description:
            - Username used to login to the switch
        required: true
        default: 'admin'
        choices: []
        aliases: []
    password:
        description:
            - Password used to login to the switch
        required: true
        default: 'C1sco12345'
        choices: []
        aliases: []
    protocol:
        description:
            - Dictates connection protocol to use
        required: false
        default: https
        choices: ['http', 'https']
        aliases: []
'''

EXAMPLES =  '''

 aci_bridge_domain:
     action: "{{ action }}"
     tenant_name: "{{ tenant_name }}" 
     bd_name: "{{ bd_name }}" 
     vrf_name: "{{ vrf_name }}"
     arp_flooding: "{{ arp_flooding }}"
     l2_unknown_unicast: "{{ l2_unknown_unicast }}"
     l3_unknown_multicast: "{{ l3_unknown_multicast }}"
     multi_dest: "{{ multi_dest }}"
     l3_out: "{{ l3_out }}"
     gateway_ip: "{{ gateway_ip }}"
     subnet_mask: "{{ subnet_mask }}"
     scope: "{{ scope }}"
     dhcp_name: "{{ dhcp_name }}"
     dhcp_scope: "{{ dhcp_scope }}"
     host: "{{ inventory_hostname }}"
     username: "{{ username }}"
     password: "{{ password }}"


'''

import socket
import json
import requests


def main():
    ''' Ansible module to take all the parameter values from the playbook '''

    module = AnsibleModule(argument_spec=dict(
        action=dict(choices=['get', 'post']),
        tenant_name=dict(type='str', required=True),
        bd_name=dict(type='str', required=True),
        arp_flooding=dict(choices=['yes','no'], default="yes"),
        l2_unknown_unicast=dict(choices=['proxy','flood'], default='proxy'),
        l3_unknown_multicast=dict(choices=['flood','opt-flood'], default='flood'),
        multi_dest=dict(choices=['bd-flood','drop','encap-flood'], default='bd-flood'),
        l3_out=dict(type='str'),
        vrf_name=dict(type='str'),
        gateway_ip=dict(type='str'),
        subnet_mask=dict(type='str'),
        scope=dict(type='str',default='private'),
        dhcp_name=dict(type='str'),
        dhcp_scope=dict(choices=['tenant','infra'],default='infra'),
        host=dict(required=True),
        username=dict(type='str', default='admin'),
        password=dict(type='str'),
        protocol=dict(choices=['http', 'https'], default='https'),
        ), supports_check_mode=False)

    tenant_name = module.params['tenant_name']
    host = socket.gethostbyname(module.params['host'])
    bd_name = module.params['bd_name']
    arp_flooding = module.params['arp_flooding']
    l2_unknown_unicast = module.params['l2_unknown_unicast']
    l3_unknown_multicast = module.params['l3_unknown_multicast']
    multi_dest = module.params['multi_dest']
    l3_out = module.params['l3_out']
    vrf_name = module.params['vrf_name']
    username = module.params['username']
    password = module.params['password']
    protocol = module.params['protocol']
    action = module.params['action']

    #subnet
    gateway_ip = module.params['gateway_ip']
    subnet_mask = module.params['subnet_mask']
    ip = gateway_ip + "/" + subnet_mask
    scope = module.params['scope']
   
    #DHCP Relay Labels
    dhcp_name = module.params['dhcp_name']
    dhcp_scope = module.params['dhcp_scope']

    post_uri = 'api/mo/uni/tn-' + tenant_name + '/BD-' + bd_name + '.json'
    get_uri = 'api/node/class/fvBD.json'

    config_data = {
         "fvBD": {
             "attributes": {
                  "descr": "test",
                  "arpFlood": arp_flooding,
                  "unkMacUcastAct":l2_unknown_unicast,
                  "unkMcastAct": l3_unknown_multicast,
                  "multiDstPktAct": multi_dest
               },
              "children":[{  
                  "fvRsBDToOut":{  
                     "attributes":{  
                        "tnL3extOutName":l3_out
                           }
                      }
                  },
                  {
                      "fvRsCtx": {
                          "attributes": {
                              "tnFvCtxName": vrf_name
                         }
                      }
                  },
                  {
                   "fvSubnet":{
                      "attributes":{
                          "ip": ip,
                          "scope": scope
                      	}
	            }
                  },
                  {
                   "dhcpLbl":{
                     "attributes": {
                       "name": dhcp_name,
                       "owner": dhcp_scope
                        }
                     }
                  }
		]
              
           }
     }

    payload_data = json.dumps(config_data)

    apic = '{0}://{1}/'.format(protocol, host)

    auth = dict(aaaUser=dict(attributes=dict(name=username,
                pwd=password)))
    url = apic + 'api/aaaLogin.json'

    authenticate = requests.post(url, data=json.dumps(auth), timeout=2,
                                 verify=False)

    if authenticate.status_code != 200:
        module.fail_json(msg='could not authenticate to apic',
                         status=authenticate.status_code,
                         response=authenticate.text)

    if post_uri.startswith('/'):
        post_uri = post_uri[1:]
    post_url = apic + post_uri

    if get_uri.startswith('/'):
        get_uri = get_uri[1:]
    get_url = apic + get_uri

    if action == 'post':
        req = requests.post(post_url, cookies=authenticate.cookies,
                            data=payload_data, verify=False)
    elif action == 'get':
        req = requests.get(get_url, cookies=authenticate.cookies,
                           data=payload_data, verify=False)

    response = req.text
    status = req.status_code
   
    changed = False
    if req.status_code == 200:
        if action == 'post':
            changed = True
        else:
            changed = False
    else:
        module.fail_json(msg=response,
                         response=response, status=status)

    results = {}
    results['status'] = status
    results['response'] = response
    results['changed'] = changed

    module.exit_json(**results)

from ansible.module_utils.basic import *
try:
    main()
except:
    pass
